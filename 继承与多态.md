# 父类与子类
> 1.子类可以访问与继承来自父类的公共的数据与方法
>
> 2.例如：public class Circle extends GeometricObject
> 
> 3.关键字：
> - this:用于同一个类中的重名的数据
> - super：用于指向父类重名的数据
# 构造方法链
> 1.在任何的情况下，当构造一个类时，会调用沿着继承链的所有父类的构造方法
>
> 2.调用顺序在完成自己的构造方法之前，默认调用一个传入参数为空的父类构造方式
>
> 3.其中Object是所有类的父类
# 方法的重写与重载
> 重载：
> - 要求：保持多个方法的方法名相同，传入参数不同，返回参数无关
> - 重载主要实现了根据传入的不同参数分别实现不同的功能
> 
> 重写：
> - 要求：在子类与父类之间保证方法的签名(方法名，传入参数)以及相同或可兼容的返回类型
> - 重写标注：@Override
> - 重写保证了在一个父子链上，不同的类都有独特的但总功能类似的作用\
> 例如：
> > - Object中有一个toString的方法，该方法会返回一个描述该对象的字符串：对象类名@以十六进制表示的该对象的内存地址
> > - 我们可以根据需要完成所对应的对象的toString方法
# 多态
> 1.概念：
> 
> 使用父类型的地方都可以使用子类型，多态意味着父类型变量可以引用子类型的对象
>
> 2.动态绑定：
>
> - 由于方法可以在继承链上的多个类中实现，所以为了确定具体的方式，JVM会根据声明类型的实际类型去决定使用哪个方法
> - 如果该对应的类中没有对应的方法，则会沿着方法链向父类去查找，直到Object类
# 对象转换与instanceof
> 一个对象的引用可以类型转换为对另外一个对象的引用
> - 一个子类总是可以转换为一个父类的变量，向上转换
> - 一个父类不总是能成功的转换为一个子类，当父类对象是子类的实例的时候，可以通过强制转换（显示转换）将父类转换为子类
> 
> 为了判别一个对象是否是另一个对象的实例，通常通过instanceof关键字:
> - if (myObject instanceof Circle)
# Object类的equals方法
> - 在Object类中，equals方法是通过判断对象的引用是否相同实现的
> - 所以在很多子类中，很多类都重写类equals方法，可以判别对象中的内容是否相同
# ArrayList类
> 位于java.util.ArrayList\
> ArrayList中声明的元素必须是一个对象
>
> 声明：
> - ArrayList<String> cities = new ArraryList<String> ()
> - ArraryList<java.util.Date> dates = new ArraryList<java.util.Date> ()
>
> 