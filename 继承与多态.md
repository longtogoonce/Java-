# 父类与子类
> 1.子类可以访问与继承来自父类的公共的数据与方法
>
> 2.例如：public class Circle extends GeometricObject
> 
> 3.关键字：
> - this:用于同一个类中的重名的数据
> - super：用于指向父类重名的数据
# 构造方法链
> 1.在任何的情况下，当构造一个类时，会调用沿着继承链的所有父类的构造方法
>
> 2.调用顺序在完成自己的构造方法之前，默认调用一个传入参数为空的父类构造方式
>
> 3.其中Object是所有类的父类
# 方法的重写与重载
> 重载：
> - 要求：保持多个方法的方法名相同，传入参数不同，返回参数无关
> - 重载主要实现了根据传入的不同参数分别实现不同的功能
> 
> 重写：
> - 要求：在子类与父类之间保证方法的签名(方法名，传入参数)以及相同或可兼容的返回类型
> - 重写标注：@Override
> - 重写保证了在一个父子链上，不同的类都有独特的但总功能类似的作用\
> 例如：
> > - Object中有一个toString的方法，该方法会返回一个描述该对象的字符串：对象类名@以十六进制表示的该对象的内存地址
> > - 我们可以根据需要完成所对应的对象的toString方法
# 多态
> 1.概念：
> 
> 使用父类型的地方都可以使用子类型，多态意味着父类型变量可以引用子类型的对象
>
> 2.动态绑定：
>
> - 由于方法可以在继承链上的多个类中实现，所以为了确定具体的方式，JVM会根据声明类型的实际类型去决定使用哪个方法
> - 如果该对应的类中没有对应的方法，则会沿着方法链向父类去查找，直到Object类
>
> 3.总结：
> - 一个变量的静态类型决定了它可以访问哪些方法和属性
> - 但是方法的具体实现是在运行时确定的
> - 当调用一个对象的方法时，编译器会根据变量的静态类型选择相应的方法签名
> - 但是具体调用哪个实现是在运行时根据对象的实际类型决定的
> 
> 4.例子：
> - 假设有一个 Animal 类和一个 Dog 类继承自 Animal，并且它们都有一个 makeSound() 方法。如果我们声明一个 Animal 类型的变量 a，并将其引用指向一个 Dog 对象，那么调用 a.makeSound() 方法时，实际上会调用 Dog 类中的 makeSound() 方法。这是因为方法的选择是在运行时决定的，而在运行时，a 引用的对象是 Dog 类型的，所以会选择 Dog 类中的 makeSound() 方法。

# 对象转换与instanceof
> 一个对象的引用可以类型转换为对另外一个对象的引用
> - 一个子类总是可以转换为一个父类的变量，向上转换
> - 一个父类不总是能成功的转换为一个子类，当父类对象是子类的实例的时候，可以通过强制转换（显示转换）将父类转换为子类
> 
> 为了判别一个对象是否是另一个对象的实例，通常通过instanceof关键字:
> - if (myObject instanceof Circle)
# Object类的equals方法
> - 在Object类中，equals方法是通过判断对象的引用是否相同实现的
> - 所以在很多子类中，很多类都重写类equals方法，可以判别对象中的内容是否相同
# ArrayList类
> 位于java.util.ArrayList\
> ArrayList中声明的元素必须是一个对象
>
> 声明：
> - ArrayList<String> cities = new ArraryList<String> ()
> - ArraryList<java.util.Date> dates = new ArraryList<java.util.Date> ()
# 可见修饰符
> 只能修饰类的成员：
> - private ： 只有类中可见
> - protected : 位于同一个包中，和不同包的子类中使用
> 
> 既可以修饰类的成员也可以修饰类变量：
> - default : 在同一个包中
> - public ： 公共的
# 防止继承与重写
> final关键字：
> - 定义了一个方法是最终的，不能被重写
> - 修饰数据域是一个常数